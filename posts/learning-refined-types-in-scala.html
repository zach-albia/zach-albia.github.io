<!DOCTYPE html><html lang="en"><head><meta charSet="UTF-8"/><title>Learning Refined Types in Scala - Zach&#x27;s Programming Blog</title><meta name="description" content="Next.js starter blog"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="alternate" title="RSS Feed" type="application/json" href="https://zach-albia.github.io/feed.json"/><meta property="og:url" content="https://zach-albia.github.io"/><meta property="og:title" content="Learning Refined Types in Scala"/><meta property="og:description" content="Next.js starter blog"/><meta name="twitter:site" content="https://zach-albia.github.io"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:image" content="https://zach-albia.github.io/static/site-feature.png"/><meta property="og:image" content="https://zach-albia.github.io/static/site-feature.png"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/4bQdlgg9WjrY1tTyEGzfG/pages/posts/learning-refined-types-in-scala.js" as="script"/><link rel="preload" href="/_next/static/4bQdlgg9WjrY1tTyEGzfG/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-91b117697e716c22a78b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.74d547792b3163b4d6d2.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.6b5b42654657d9aebcbb.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-585248bbf88b18432f6a.js" as="script"/><link rel="preload" href="/_next/static/chunks/519fbf2bbd9447c92c1b96d8d8d142b0fc35f164.10b9c370efd7970aeef0.js" as="script"/><link rel="preload" href="/_next/static/chunks/7aadee6ad1c79e42a529ea224b721a183d70e170.ede9e800f277f0f3ce47.js" as="script"/><style id="__jsx-35041104">h1.jsx-35041104{margin-top:0;}a.jsx-35041104{color:#333;-webkit-text-decoration:none;text-decoration:none;}p.jsx-35041104{font-size:1.3em;font-weight:bold;}</style><style id="__jsx-3928104162">nav.jsx-3928104162{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}a.jsx-3928104162:not(:last-child){margin-right:1em;}</style><style id="__jsx-1260337168">header.jsx-2576568336{padding:1em 0;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}</style><style id="__jsx-1749265417">html{margin:0;box-sizing:border-box;}*,*:before,*:after{box-sizing:inherit;}body{margin:0;font-size:18px;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto, Oxygen-Sans,Ubuntu,Cantarell,'Helvetica Neue',sans-serif;color:#333;line-height:1.5;background-color:#fff;}h1,h2,h3,h4{margin-bottom:0.5rem;font-weight:bold;color:inherit;line-height:1.25;}h1{font-size:2rem;}h2{margin-top:1rem;font-size:1.8rem;}h3{margin-top:1.5rem;font-size:1.5rem;}p{margin-top:0;margin-bottom:1rem;}ul,ol,dl{margin-top:0;margin-bottom:1rem;}a{color:#33e;cursor:pointer;}a:hover,a:focus{-webkit-text-decoration:underline;text-decoration:underline;}hr{position:relative;margin:1.5em 0;border:0;border-top:1px solid #eee;border-bottom:1px solid #fff;}blockquote{padding:0.5em 1em;margin:0.8em 0;color:#555;border-left:0.25em solid #ccc;}blockquote p:last-child{margin-bottom:0;}pre code{font-size:18px;}code{color:#fff;}.wrap{max-width:38rem;margin-left:auto;margin-right:auto;}article img{max-width:100%;height:auto;}</style><style id="__jsx-2086094107">code[class*='language-'],pre[class*='language-']{color:#f8f8f2;background:none;font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;}pre[class*='language-']{padding:1em;margin:0.5em 0;overflow:auto;border-radius:0.3em;}:not(pre)>code[class*='language-'],pre[class*='language-']{background:#2b2b2b;}:not(pre)>code[class*='language-']{padding:0.1em;border-radius:0.3em;white-space:normal;}.token.comment,.token.prolog,.token.doctype,.token.cdata{color:#d4d0ab;}.token.punctuation{color:#fefefe;}.token.property,.token.tag,.token.constant,.token.symbol,.token.deleted{color:#ffa07a;}.token.boolean,.token.number{color:#00e0e0;}.token.selector,.token.attr-name,.token.string,.token.char,.token.builtin,.token.inserted{color:#abe338;}.token.operator,.token.entity,.token.url,.language-css .token.string,.style .token.string,.token.variable{color:#00e0e0;}.token.atrule,.token.attr-value,.token.function{color:#ffd700;}.token.keyword{color:#00e0e0;}.token.regex,.token.important{color:#ffd700;}.token.important,.token.bold{font-weight:bold;}.token.italic{font-style:italic;}.token.entity{cursor:help;}@media screen and (-ms-high-contrast:active){code[class*='language-'],pre[class*='language-']{color:windowText;background:window;}:not(pre)>code[class*='language-'],pre[class*='language-']{background:window;}.token.important{background:highlight;color:window;font-weight:normal;}.token.atrule,.token.attr-value,.token.function,.token.keyword,.token.operator,.token.selector{font-weight:bold;}.token.attr-value,.token.comment,.token.doctype,.token.function,.token.keyword,.token.operator,.token.property,.token.string{color:highlight;}.token.attr-value,.token.url{font-weight:normal;}}code{padding:0.1em 0.2em;background-color:#2b2b2b;border-radius:0.3em;}code[class*='language-'],pre[class*='language-']{font-size:16px;line-height:1.3;}pre[class*='language-']{margin-bottom:1em;}pre[class='language-jsx']{padding-bottom:0;}.mdx-marker{background-color:rgba(255,255,255,0.1);display:block;margin-right:-1em;margin-left:-1em;padding-right:1em;padding-left:0.75em;border-left:0.25em solid #ffdc00;}</style><style id="__jsx-2576154369">a.jsx-2576154369{color:#555;-webkit-text-decoration:none;text-decoration:none;}</style><style id="__jsx-1802794746">a.jsx-1802794746{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;text-align: right; grid-column: 2 / 2;;}</style><style id="__jsx-1238384267">header.jsx-1238384267{margin-bottom:2em;}[rel='author'].jsx-1238384267{margin-left:1em;}article.jsx-1238384267{margin-bottom:2em;}footer.jsx-1238384267{margin-top:2em;}.post-pagination.jsx-1238384267{display:grid;grid-template-columns:1fr 1fr;}</style><style id="__jsx-140955737">.profile.jsx-140955737{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:1em;background-color:#eee;}img.jsx-140955737{width:5em;height:5em;margin-right:0.5em;}p.jsx-140955737:last-child{margin-bottom:0;}</style><style id="__jsx-3055961061">footer.jsx-3055961061{padding:1em 0;}p.jsx-3055961061{margin-top:2em;}</style><style id="__jsx-3779335083">.jsx-3779335083{max-width:45rem;margin:0 auto;padding:0 1em;}</style></head><body><div id="__next"><div class="jsx-3779335083"><header class="jsx-2576568336"><p class="jsx-35041104"><a rel="me" class="jsx-35041104" href="/">Zach&#x27;s Programming Blog</a></p><nav class="jsx-3928104162"><a class="jsx-3928104162" href="/about">About</a></nav></header><main><article class="jsx-1238384267 h-entry"><header class="jsx-1238384267"><h1 class="jsx-1238384267 p-name">Learning Refined Types in Scala</h1><div class="jsx-1238384267"><a href="/posts/learning-refined-types-in-scala" mcolor="#aaa" date="2017-10-21" link="/posts/learning-refined-types-in-scala" class="jsx-2576154369 u-url"><time class="jsx-2576154369 dt-published">October 21, 2017</time></a><a color="#aaa" rel="author" href="/about" class="jsx-1238384267 p-author h-card">Zachary Albia</a></div></header><div class="jsx-1238384267 e-content"><div><h1>Refined</h1><p><a href="https://github.com/fthomas/refined">Refined</a> has some practical, useful ideas. There are obvious, clear benefits to domain modeling with refined types. Learning to use the library and getting used to it does have some overhead though, as with any new thing. We&#x27;ll be getting into the nitty-gritty of that overhead as I learn the library.</p><p>To have something to base this series on, I&#x27;ll work on <code>adriann</code>&#x27;s <a href="https://adriann.github.io/programming_problems.html">Simple Programming Problems</a>, starting with Elementary Problem 3. We&#x27;re skipping 1 and 2 because they&#x27;re trivial and don&#x27;t benefit from refined types, anyway.</p><p>Here&#x27;s the problem statement:</p><blockquote><ol start="3"><li>Modify the previous program such that only the users Alice and Bob are greeted with their names.</li></ol></blockquote><p>And here&#x27;s a solution to Problem 3:</p><pre class="language-scala"><code class="language-scala" metaString=""><span class="token keyword">import</span> <span class="token namespace">scala<span class="token punctuation">.</span>io</span><span class="token punctuation">.</span>StdIn<span class="token punctuation">.</span>_

<span class="token keyword">object</span> Prob3 <span class="token punctuation">{</span>

  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span>
    println<span class="token punctuation">(</span>greet<span class="token punctuation">(</span>readLine<span class="token punctuation">(</span><span class="token string">&quot;What&#x27;s your name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword">def</span> greet<span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> <span class="token string">&quot;Alice&quot;</span> <span class="token operator">||</span> name <span class="token operator">==</span> <span class="token string">&quot;Bob&quot;</span><span class="token punctuation">)</span> s<span class="token string">&quot;Hello, $name!&quot;</span>
    <span class="token keyword">else</span> <span class="token string">&quot;Go away!&quot;</span>
<span class="token punctuation">}</span>
</code></pre><p>So we&#x27;re reading a line, making a greeting out of the name the user enters, and printing that greeting to the console. Our greeting can be polite, if your name&#x27;s either <em>Alice</em> or <em>Bob</em>. We changed the problem a bit by being a bit standoffish to anyone with any other name.</p><p>What if we we&#x27;re given an empty <code>String</code>? It&#x27;d be awkward to say <code>&quot;Go away, !&quot;</code>. Like stuttering, but in writing. Let&#x27;s say we don&#x27;t ever want an empty <code>String</code> for <code>greet</code>.</p><p>Enter refined types.</p><p>First off, we could fix it in a lot of ways, but there&#x27;s already <a href="https://beyondthelines.net/programming/refined-types/">a good writeup</a> on why refined types are, at least IMO, one of the better ways. So let&#x27;s use them here.</p><p>First, we change our <code>greet</code>&#x27;s signature:</p><pre class="language-scala"><code class="language-scala" metaString=""><span class="token keyword">def</span> greet<span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">String</span> Refined NonEmpty<span class="token punctuation">)</span>
</code></pre><p>Already, we run into a problem in <code>main</code>, because <code>readLine</code> returns a <code>String</code>, while <code>greet</code> now wants a <code>NonEmptyString</code>. While we&#x27;re at it, let&#x27;s add an alias for brevity:</p><pre class="language-scala"><code class="language-scala" metaString=""><span class="token keyword">type</span> NonEmptyString <span class="token operator">=</span> <span class="token builtin">String</span> Refined NonEmpty
</code></pre><p>We also have another, more pernicious problem in that we&#x27;re comparing the equality of a <code>String</code> to a <code>NonEmptyString</code>, which is a patently bad idea. The culprit here is <code>name == &quot;Alice&quot; || name == &quot;Bob&quot;</code>.</p><p>At this point, I think it&#x27;s a good time to use Scalaz&#x27;s type-safe <code>Equal</code>. Let&#x27;s change the expression to <code>name === &quot;Alice&quot; || name === &quot;Bob&quot;</code>.</p><p>Now we have three errors, namely:</p><pre class="language-scala"><code class="language-scala" metaString=""><span class="token punctuation">[</span>error<span class="token punctuation">]</span> value <span class="token operator">==</span><span class="token operator">=</span> is not a member of eu<span class="token punctuation">.</span>timepit<span class="token punctuation">.</span>refined<span class="token punctuation">.</span>api<span class="token punctuation">.</span>Refined<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">,</span>eu<span class="token punctuation">.</span>timepit<span class="token punctuation">.</span>refined<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>NonEmpty<span class="token punctuation">]</span>
<span class="token punctuation">[</span>error<span class="token punctuation">]</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">&quot;Alice&quot;</span> <span class="token operator">||</span> name <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">&quot;Bob&quot;</span><span class="token punctuation">)</span> s<span class="token string">&quot;Hello, $name!&quot;</span>
<span class="token punctuation">[</span>error<span class="token punctuation">]</span>              <span class="token operator">^</span>
<span class="token punctuation">[</span>error<span class="token punctuation">]</span> value <span class="token operator">==</span><span class="token operator">=</span> is not a member of eu<span class="token punctuation">.</span>timepit<span class="token punctuation">.</span>refined<span class="token punctuation">.</span>api<span class="token punctuation">.</span>Refined<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">,</span>eu<span class="token punctuation">.</span>timepit<span class="token punctuation">.</span>refined<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>NonEmpty<span class="token punctuation">]</span>
<span class="token punctuation">[</span>error<span class="token punctuation">]</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">&quot;Alice&quot;</span> <span class="token operator">||</span> name <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">&quot;Bob&quot;</span><span class="token punctuation">)</span> s<span class="token string">&quot;Hello, $name!&quot;</span>
<span class="token punctuation">[</span>error<span class="token punctuation">]</span>                                  <span class="token operator">^</span>
<span class="token punctuation">[</span>error<span class="token punctuation">]</span> <span class="token keyword">type</span> mismatch<span class="token punctuation">;</span>
<span class="token punctuation">[</span>error<span class="token punctuation">]</span>  found   <span class="token operator">:</span> <span class="token builtin">String</span>
<span class="token punctuation">[</span>error<span class="token punctuation">]</span>  required<span class="token operator">:</span> eu<span class="token punctuation">.</span>timepit<span class="token punctuation">.</span>refined<span class="token punctuation">.</span>api<span class="token punctuation">.</span>Refined<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">,</span>eu<span class="token punctuation">.</span>timepit<span class="token punctuation">.</span>refined<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>NonEmpty<span class="token punctuation">]</span>
</code></pre><p>This is a strictly better outcome than trying to compare the name read from user input, only for our conditional to always come up <code>false</code> because they aren&#x27;t the same type! So how do we make our Equal typeclass work for refined types?</p><p>It turns out <code>refined</code> has support for <code>Equal</code> so let&#x27;s go with that and <code>import eu.timepit.refined.scalaz._</code>. Note that we&#x27;ve had to add the dependency in <code>build.sbt</code> with: <code>libraryDependencies += &quot;eu.timepit&quot; %% &quot;refined-scalaz&quot; % &quot;0.8.4&quot;</code>. Refined also provides a way to automatically <em>lift</em> literals into refined types, so let&#x27;s use them with <code>import eu.timepit.refined.auto._</code>.</p><p>Now that we&#x27;ve resolved the errors in our conditional, we are left with the following new error:</p><pre><code>[error] compile-time refinement only works with literals
[error]     println(greet(readLine(&quot;What&#x27;s your name? &quot;)))
[error]                           ^
</code></pre><p>And for good reason. There isn&#x27;t a way for our compiler to know if our user is entering a <code>NonEmptyString</code>! The user can choose <em>not</em> to enter anything after all. With that in mind, we have to resolve the type <strong>at runtime</strong>. To do this, we <em>refine</em> our user input at runtime.</p><pre class="language-scala"><code class="language-scala" metaString=""><span class="token keyword">import</span> <span class="token namespace">eu<span class="token punctuation">.</span>timepit<span class="token punctuation">.</span>refined<span class="token punctuation">.</span>refineV</span>

<span class="token keyword">val</span> refinedUserInput<span class="token operator">:</span> Either<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">,</span> Refined<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">,</span> NonEmpty<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> 
      refineV<span class="token punctuation">[</span>NonEmpty<span class="token punctuation">]</span><span class="token punctuation">(</span>readLine<span class="token punctuation">(</span><span class="token string">&quot;What&#x27;s your name? &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><p>When refining values at runtime, we end up with an <code>Either[String, Refined[_, _]]</code>. At this point, we know we&#x27;ve reached the edge of our program. We <em>have</em> to rewrite <code>main</code>. </p><pre class="language-scala"><code class="language-scala" metaString=""><span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  refineV<span class="token punctuation">[</span>NonEmpty<span class="token punctuation">]</span><span class="token punctuation">(</span>readLine<span class="token punctuation">(</span><span class="token string">&quot;What&#x27;s your name? &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">match</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> Right<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> println<span class="token punctuation">(</span>greet<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> Left<span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span> <span class="token comment">// what to do here?</span>
  <span class="token punctuation">}</span>
</code></pre><p>By using refined types, we are <em>eventually forced</em> to deal with the case where our user enters an invalid name. Let&#x27;s say we decide to just tell the user that they didn&#x27;t enter a name. We can do that here.</p><pre class="language-scala"><code class="language-scala" metaString=""><span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  refineV<span class="token punctuation">[</span>NonEmpty<span class="token punctuation">]</span><span class="token punctuation">(</span>readLine<span class="token punctuation">(</span><span class="token string">&quot;What&#x27;s your name? &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">match</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> Right<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> println<span class="token punctuation">(</span>greet<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> _ <span class="token keyword">=&gt;</span> println<span class="token punctuation">(</span><span class="token string">&quot;You didn&#x27;t enter a name!&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre><p>We can even ask the user again, with recursion.</p><pre class="language-scala"><code class="language-scala" metaString=""><span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span>
  refineV<span class="token punctuation">[</span>NonEmpty<span class="token punctuation">]</span><span class="token punctuation">(</span>readLine<span class="token punctuation">(</span><span class="token string">&quot;What&#x27;s your name? &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">match</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> Right<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> println<span class="token punctuation">(</span>greet<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> _ <span class="token keyword">=&gt;</span>
      println<span class="token punctuation">(</span><span class="token string">&quot;You didn&#x27;t enter a name!&quot;</span><span class="token punctuation">)</span>
      main<span class="token punctuation">(</span>args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre><p>Here&#x27;s the whole code:</p><pre class="language-scala"><code class="language-scala" metaString=""><span class="token keyword">import</span> scalaz<span class="token punctuation">.</span>_
<span class="token keyword">import</span> Scalaz<span class="token punctuation">.</span>_
<span class="token keyword">import</span> <span class="token namespace">eu<span class="token punctuation">.</span>timepit<span class="token punctuation">.</span>refined<span class="token punctuation">.</span>api</span><span class="token punctuation">.</span>Refined
<span class="token keyword">import</span> <span class="token namespace">eu<span class="token punctuation">.</span>timepit<span class="token punctuation">.</span>refined<span class="token punctuation">.</span>collection</span><span class="token punctuation">.</span>NonEmpty
<span class="token keyword">import</span> <span class="token namespace">eu<span class="token punctuation">.</span>timepit<span class="token punctuation">.</span>refined<span class="token punctuation">.</span>scalaz</span><span class="token punctuation">.</span>_
<span class="token keyword">import</span> <span class="token namespace">eu<span class="token punctuation">.</span>timepit<span class="token punctuation">.</span>refined<span class="token punctuation">.</span>auto</span><span class="token punctuation">.</span>_
<span class="token keyword">import</span> <span class="token namespace">eu<span class="token punctuation">.</span>timepit<span class="token punctuation">.</span>refined<span class="token punctuation">.</span>refineV</span>

<span class="token keyword">import</span> <span class="token namespace">scala<span class="token punctuation">.</span>io</span><span class="token punctuation">.</span>StdIn<span class="token punctuation">.</span>_

<span class="token keyword">object</span> Prob3 <span class="token punctuation">{</span>

  <span class="token keyword">type</span> NonEmptyString <span class="token operator">=</span> <span class="token builtin">String</span> Refined NonEmpty

  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span>
    refineV<span class="token punctuation">[</span>NonEmpty<span class="token punctuation">]</span><span class="token punctuation">(</span>readLine<span class="token punctuation">(</span><span class="token string">&quot;What&#x27;s your name? &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">match</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> Right<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> println<span class="token punctuation">(</span>greet<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">case</span> _ <span class="token keyword">=&gt;</span>
        println<span class="token punctuation">(</span><span class="token string">&quot;You didn&#x27;t enter a name!&quot;</span><span class="token punctuation">)</span>
        main<span class="token punctuation">(</span>args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

  <span class="token keyword">def</span> greet<span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">String</span> Refined NonEmpty<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">String</span> <span class="token operator">=</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">&quot;Alice&quot;</span> <span class="token operator">||</span> name <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">&quot;Bob&quot;</span><span class="token punctuation">)</span> s<span class="token string">&quot;Hello, $name!&quot;</span>
    <span class="token keyword">else</span> s<span class="token string">&quot;Go away, $name!&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div></div><footer class="jsx-1238384267"><div class="jsx-1238384267 post-pagination"><a class="jsx-1802794746" href="/posts/learning-eff"><small class="jsx-1802794746">Read <!-- -->next<!-- --> post </small>Learning Eff</a></div></footer></article></main><footer class="jsx-3055961061"><div class="jsx-140955737 h-card profile"><img src="/static/chibi.png" alt="Zachary Albia" class="jsx-140955737 u-photo"/><div class="jsx-140955737"><p class="jsx-140955737">Hi, I&#x27;m<!-- --> <a href="https://zach-albia.github.io" rel="me" class="jsx-140955737 u-url p-name">Zachary Albia</a>.</p><p class="jsx-140955737 p-note">Functional programming, Scala and TypeScript have been my focus lately.</p></div></div><p class="jsx-3055961061">Proudly built with <a href="https://nextjs.org" class="jsx-3055961061">Next.js</a> -<!-- --> <a href="/feed.json" class="jsx-3055961061">RSS Feed</a></p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/posts/learning-refined-types-in-scala","query":{},"buildId":"4bQdlgg9WjrY1tTyEGzfG","nextExport":true,"autoExport":true}</script><script nomodule="" src="/_next/static/runtime/polyfills-f4f9c501a023823ba3a2.js"></script><script async="" data-next-page="/posts/learning-refined-types-in-scala" src="/_next/static/4bQdlgg9WjrY1tTyEGzfG/pages/posts/learning-refined-types-in-scala.js"></script><script async="" data-next-page="/_app" src="/_next/static/4bQdlgg9WjrY1tTyEGzfG/pages/_app.js"></script><script src="/_next/static/runtime/webpack-91b117697e716c22a78b.js" async=""></script><script src="/_next/static/chunks/framework.74d547792b3163b4d6d2.js" async=""></script><script src="/_next/static/chunks/commons.6b5b42654657d9aebcbb.js" async=""></script><script src="/_next/static/runtime/main-585248bbf88b18432f6a.js" async=""></script><script src="/_next/static/chunks/519fbf2bbd9447c92c1b96d8d8d142b0fc35f164.10b9c370efd7970aeef0.js" async=""></script><script src="/_next/static/chunks/7aadee6ad1c79e42a529ea224b721a183d70e170.ede9e800f277f0f3ce47.js" async=""></script><script src="/_next/static/4bQdlgg9WjrY1tTyEGzfG/_buildManifest.js" async=""></script></body></html>